# Реализация алгоритма Эрли.
## Описание формата ввода
Есть 2 специальных символа: `:`, `|`.

Давайте распшем ввод по строкам
1) `Not terminal:`
2) Здесь идёт перечисление нетерминальных символов (просто в строчку, без пробелов и других символов разделителей)
3) `Starting symbol:`
4) Здесь собственно начальный символ из нетерминальных (его не должно быть в правой части никакого правила).
5) `Rules:`
6) Здесь перечисляете правила, можно перечислять правила каждое в своей строчке, 
Пример `S:abc` - это равносильно записи `S->abc`. Если хотите перечислить несколько правил подряд необходимо
написать `S:abc|cde`, т.е. перечислить их через знак `|`. (Никаких лишних пробелов и разделителей быть не должно).
Чтобы добавить эпсилон-переход можно либо написать `S:`, либо после последнего символа `|` сделать перенос строки.
7) `End` 

Далее можно вводить слово для проверки. Слово считывается до переноса строки. Пример корректного ввода можно увидеть 
в файле `input`.
## Как собирать.
Для сборки проделайте следующие команды (для `Linux`):
1) `mkdir build`
2) `cd build`
3) `cmake ..`
4) `make`

Теперь у вас будут 2 исполняемых файла `unit_tests` и `Earley`.
## Тестирование.
Тестирование производится  с помощью библиотеки `Google Test`. 
Для его выполнения запустите файл `unit_tests`.
## Запуск.
Для выполнения программы запустите файл `Earley`. Результатом будет `Accept` в случае 
если слово выводится в грамматике, иначе `Reject`.
## Оценка времени работы.
Пусть размер грамматики (суммарня её длина) - константа, обозначим её `|G|`. 
Длину слова обозначим за `|w|`.
* Пусть `D[i]` - список ситуаций, для которых уже было считано `i` символов.
Тогда в каждом таком массиве может быть не больще, чем `|G|^2|W|` ситуаций. 
Т.е. `O(|W|)`.
* Метод `Scan` выполняется `|w|` раз, пробегая по всем ситуациям в `D[i]` для
каждого `i`. Для каждой ситуации сканирование выполняется за `O(1)`. Суммарно `O(|w|^2)`.
* Чтобы в наши множества не добавлять лишних ситуаций, будем хранить битовую
табличку, `used[rule_idx][position_in_rule][begin_position]` - для текущего мноежества 
была ли уже добавлена ситуация с номером правила, позицией точки в правиле, и позицию в строке,
тиз которой было предсказано это правило.
* Метод `Predict`будет перебирать ситуации, начиная с первой, которая ещё не рассматривалась,
и для каждой такой ситуации перебирать правила, по которым можно сделать `Predict`. 
Для одного множества это будет работать за `O(|w|)`.
* Метод `Complete` будет перебирать для текущего множества перебирать ситуации, начиная с 
первой, которая ещё не рассматривалась. Для каждой такой ситуации он будет перебирать 
ситуации из `D[begin_position]` - позиция, с которой мы читали это правило. Т.е. `O(|w|)` ситуаций.
Для каждого такого правила, помним позицию последнего правила, которое мы ещё не рассматривали `Complete`
(такая ситуаций возникает, когда у нас правила, с которыми мы должны сделать `Complete` лежат в текущем множестве).
Тогда суммарно для каждой ситуации `Complete` будет работать за `O(|w|)`. Всего итераций `Complete` 
будет `O(|w|^2)` для одного множества и `O(|w|^3)` для всех `Complete`.